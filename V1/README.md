
Использование MicroPython для работы с ПЛК ESP32
руководство по выполнению Практического задания
Кокоулин А.Н. | Прикладное ПО АСР | 2022Оглавление
Введение	3
О контроллере ESP32	3
Основы языка Python и MicroPython	4
Введение в Python	5
Условные операторы	6
Операторы цикла	6
Ввод-вывод	8
Строки	8
Списки, кортежи, файлы	10
Списки	10
Словари	13
Тип file	13
Использование функций	14
Параметры по-умолчанию	16
Position и keyword аргументы.	16
Структура программы MicroPython	17
Библиотеки и модули	18
Подключаемся к сети	18
Пример программы	19
Симулятор ESP32	20
Эмуляция сетевых подключений (WiFi)	22
Работа с MQTT с использованием сетевых подключений	25
MQTT – система обмена сообщениями с использованием брокера	25
Семантика топиков	26
Структура сообщений	27
Задание на выполнение практической работы:	34
Приложение 1	36
Общее управление платой	36
Сеть	36
Задержки и синхронизация	37
Таймеры	37
Контакты и GPIO	38
ШИМ (широтно-импульсная модуляция)	38
АЦП (аналогово-цифровое преобразование)	39
Введение
MicroPython – это минимизированная и эффективная реализация языка программирования Python 3, включающая в себя небольшую часть стандартной библиотеки Python и оптимизированная для работы на микроконтроллерах и в ограниченных условиях. В MicroPython имеется широкое разнообразие продвинутых функций: интерактивная командная строка, поддержка целых чисел произвольной точности, замыкания, списковое включение, генераторы, обработка исключений и многое другое. Но при этом он достаточно компактен, чтобы уместиться в пределах 256 Кб кодового пространства и 16 Кб памяти RAM.
О контроллере ESP32
ESP32 – это популярное SoC-устройство (от англ. «system on chip», т.е. «система на чипе») с функциями WiFi и Bluetooth, разработанное Espressif Systems.

Платы и модули с чипом ESP32 выпускаются разными компаниями, поэтому на рынке можно найти много разных моделей. 
В целях создания максимально универсального ESP32-порта были приняты следующие конструкторские решения:
Нумерация GPIO-контактов соответствует физической нумерации контактов ESP32-чипа. 
В MicroPython поддерживаются все контакты ESP32, но не каждая модель платы/модуля поддерживает использование всех контактов. Например, контакты, подключенные к внешнему чипу SPI flash, использовать нельзя, а ваша плата может быть сконструирована таким образом, что у нее могут быть выведены не все контакты ESP32-чипа.

Основы языка Python и MicroPython 
Python — высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью, ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ. Язык является полностью объектно-ориентированным в том плане, что всё является объектами. Необычной особенностью языка является выделение блоков кода пробельными отступами. Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации. Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов. Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++.
Стандартная библиотека Python включает большой набор полезных переносимых функций, начиная с возможностей для работы с текстом и заканчивая средствами для написания сетевых приложений. Дополнительные возможности, такие как математическое моделирование, работа с оборудованием, написание веб-приложений или разработка игр, могут реализовываться посредством обширного количества сторонних библиотек, а также интеграцией библиотек, написанных на Си или C++, при этом и сам интерпретатор Python может интегрироваться в проекты, написанные на этих языках/
MicroPython включает в себя компилятор и среду выполнения, которые запускаются на микроконтроллере. Для взаимодействия пользователь может использовать интерактивную консоль для непосредственного выполнения программы. MicroPython включает в себя модули, позволяющие программисту использовать низкоуровневые возможности микроконтроллера.
Кросс-компилятор MicroPython генерирует байт-код, (*.mpy). Байт-код может быть сгенерирован как непосредственно на микроконтроллере, так и на другом устройстве. Прошивка MicroPython может использоваться без компилятора, используя только заранее сгенерированные файлы байт-кода формата *.mpy
В каждом модуле MicroPython реализована часть стандартного функционала Python. Названия MicroPython-версий стандартных Python-модулей обычно дополняются префиксом u – чтобы упростить возможность расширения. Собственные библиотеки MicroPython:
btree — библиотека для работы с BTree базами данных
framebuf — библиотека для создания двоичного изображения для внешних экранов
machine — библиотека для работы с микроконтроллером
micropython — библиотека для работы с собственными типами данных micropython
network — библиотека для работы с сетью
ubluetooth — библиотека для работы с Bluetooth
ucryptolib — библиотека для шифрования
uctypes — библиотека для взаимодействия с бинарными структурами
Так же в сборках под некоторые платформы есть специфичные только для них библиотеки. Примеры и описание модулей даны в Приложении 1.
Введение в Python
Python – язык со строгой динамической типизацией. 
Есть языки со строгой типизацией (pascal, java, c и т.п.), у которых тип переменной определяется заранее и не может быть изменен, и есть языки с динамической типизацией (python, ruby, vb), в которых тип переменной трактуется в зависимости от присвоенного значения.
Языки с динамической типизацией можно разделить еще на 2 вида. Строгие, которые не допускают неявного преобразования типа (Python) и нестрогие, которые выполняют неявные преобразования типа (например VB, в котором можно легко сложить строку '123' и число 456).
Разобравшись с классификацией Python, попробуем поработать с переменными и значениями в интерпретаторе. Код, указанный ниже, можно запускать на домашнем компьютере, требуется только установить и запустить python.
>>> a = b = 1
>>> a, b
(1, 1)
>>> b = 2
>>> a, b
(1, 2)
>>> a, b = b, a
>>> a, b
(2, 1)
Таким, образом мы видим, что присваивание осуществляется с помощью знака =. Присвоить значение можно сразу нескольким переменным. При указании интерпретатору имени переменной в интерактивном режиме, он выводит ее значение.
Следующее, что необходимо знать – как строятся базовые алгоритмические единицы – ветвления и циклы. Для начала, необходима небольшая справка. В Pythonе нет специального ограничителя блоков кода, их роль выполняют отступы. То есть, то, что написано с одинаковым отступом – является одним командным блоком. Поначалу это может показаться странным, но после легкого привыкание, понимаешь, что эта «вынужденная» мера позволяет получать очень читабельный код.
Условные операторы
Условие задается с помощью оператора if, который заканчивается «:». Альтернативные условия, которые будут выполняться если первая проверка «не прошла» задаются оператором elif. Наконец else задает ветку, которая будет выполнена если ни одно из условий не подошло.
Обратите внимание, что после ввода if интерпретатор с помощью приглашения «...» показывает, что он ожидает продолжения ввода. Чтобы сообщить ему что мы закончили, необходимо ввести пустую строку.
Операторы цикла
Простейшим случаем цикла является цикл while. В качестве параметра он принимает условие и выполняется до тех пор, пока оно истинно.
Вот маленький пример.
>>> x = 0
>>> while x<=10:
...     print x
...     x += 1
...
0
1
2
...........
10
Обратите внимание что поскольку и print x и x+=1 написаны с одинаковым отступом, они считаются телом цикла.
Второй вид циклов в Python – цикл for. Он аналогичен циклу foreach других языков. Его синтаксис условно такой:
for переменная in список:
	команды
Переменной будут присваиваться по очереди все значения из списка (на самом деле там может быть не только список, но и любой другой итератор).
Вот простой пример. В роли списка будет выступать строка, которая является ничем иным как списком символов.
>>> x = "Hello, Python!"

>>> for char in x:
...     print char
...
H
e
l
...........
!
Таким образом мы можем разложить строку по символам.
Если нужен цикл, повторяющийся определенное число раз - необходимо использовать функцию range. На входе она принимает от одного до трех параметров, на выходе возвращает список чисел, по которому мы можем «пройтись» оператором for. Вот несколько примеров использования функции range, которые объясняют роль ее параметров.
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(2, 12)
[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
>>> range(2, 12, 3)
[2, 5, 8, 11]
>>> range(12, 2, -2)
[12, 10, 8, 6, 4]

И маленький пример с циклом.
>>> for x in range(10):
...     print x
...
0
1
2
.....
9
Ввод-вывод
Последнее, что следует знать перед тем, как начать использовать Python полноценно – это как осуществляется в нем ввод-вывод.
Для вывода используется команда print, которая выводит на печать все свои аргументы в удобочитаемом виде.
Для ввода с консоли используется функция raw_input(приглашение), которая выводит на экран приглашение и ожидает ввода пользователя, возвращая то что ввел пользователь в виде своего значения.
x = int(raw_input ("Введи число:"))
print "Квадрат этого числа составляет ", x * x
Строки
Python обладает весьма богатым набором возможностей по работе со строками. Строки и строковые переменные при декларировании могут быть заключены в одинарные или двойные кавычки, строки могут использовать ESC-последовательности в стиле С, многострочные константы задаются в тройных кавычках.
>>> "hello"
'hello'
>>> 'foo bar boz'
'foo bar boz'
Cтрока представляет собой последовательность символов с произвольным доступом. Для получения части символов строки можно использовать т.н. оператор «среза». Обратите внимание, что нумерация начитается с нуля (и достаточно хаотична на первый взгляд).
>>> str = "Hello, cruel world!"
# получить 4 символ строки
>>> str[3] 
'l'
# все символы с 8 по 14
>>> str[7:14]
'cruel w'
# каждый второй символ со 2 по 13
>>> str[1:12:2]
'el,cul'
# некоторые значения можно опускать
# каждый второй символ строки.
>>> str[::2]
'Hlo re ol!'
Если опустить первый из трех параметров, он считается равным нулю, если опустить второй – срез будет продолжен до конца строки.
# первые 2 символа строки
>>> str[:2]
'He'
# вся строка кроме 2 первых символов
>>> str[2:]
'llo, cruel world!'

# последний символ
>>> str[-1]
'!' 
# второй символ с конца
>>> str[-2]
'd'
# два последних символа
>>> str[-2:]
'd!'
# все символы кроме последних двух
>>> str[:-2]
'Hello, cruel worl'
В последних версиях Python поддерживается работа с Unicode-строками.  Для задания unicode-строки в виде константы используется префикс u.
>>> uni = u"Тест"
>>> uni
u'\u0422\u0435\u0441\u0442'
Кроме того, Python позволяет создать строку в Unicode с помощью одноименной функции.
>>> uni = unicode("Тест", "UTF-8")
>>> uni
u'\u0422\u0435\u0441\u0442'
Для преобразования строки в список по определенному разделителю, используется метод split. Этот метод в качестве параметра запрашивает разделитель, а возвращает список отдельных «слов» по которому можно «пройти» в цикле for.
>>> str = "Mary has a little lamb"
>>> str.split(" ")
['Mary', 'has', 'a', 'little', 'lamb']
>>> for word in str.split(" "):
...     print word
...
Mary
has
a
little
lamb

Списки, кортежи, файлы
Кортежи
Кортежи (англ. tuple) используется для представления неизменяемой последовательности разнородных объектов. Они обычно записываются в круглых скобках, но если неоднозначности не возникает, то скобки можно опустить.
>>> t = (2, 2.05, "Hello")
>>> t
(2, 2.0499999999999998, 'Hello')
>>> (a, b, c) = t
>>> print a, b, c
2 2.05 Hello
>>> z, y, x = t
>>> print z, y, x
2 2.05 Hello
>>> a=1
>>> b=2
>>> a,b=b,a
>>> print a,b
2 1
>>> x = 12,
>>> x
(12,)
Как видно из примера, кортеж может быть использован и в левой части оператора присваивания. Значения из кортежа в левой части оператора присваивания связываются с аналогичными элементами правой части. Этот факт как раз и дает нам такие замечательные возможности как массовая инициализация переменных и возврат множества значений из функции одновременно. Последний пример демонстрирует создание кортежа из одного элемента (его часто называют синглтоном).
Списки
В Python отсутствуют массивы в традиционном понимании этого термина. Вместо них для хранения однородных (и не только) объектов используются списки. Они задаются тремя способами.
Простое перечисление:
>>> a = [2, 2.25, "Python"]
>>> a
[2, 2.25, 'Python']
Преобразуем строку в список
>>> b = list("help")
>>> b
['h', 'e', 'l', 'p']
Создание с помощью списковых включений. В данном случае мы берем кубы всех нечетных чисел от 0 до 19. 
>>> c = [x ** 3 for x in range(20) if x%2==1]
>>> c
[1, 27, 125, 343, 729, 1331, 2197, 3375, 4913, 6859]
Для работы со списками определен ряд операторов и функций:
len(s) Длина последовательности s
x in s Проверка принадлежности элемента последовательности, или принадлежности подстроки строке. Возвращает True или False
x not in s = not x in s
s + s1 Конкатенация последовательностей
s*n или n*s Последовательность из n раз повторенной s. Если n < 0, возвращается пустая последовательность.
s[i] Возвращает i-й элемент s или len(s)+i-й, если i < 0
s[i:j:d] Срез из последовательности s от i до j с шагом d будет рассматриваться ниже
min(s) Наименьший элемент s
max(s) Наибольший элемент s
s[i] = x i-й элемент списка s заменяется на x
s[i:j:d] = t Срез от i до j (с шагом d) заменяется на (список) t
del s[i:j:d] Удаление элементов среза из последовательности
Кроме того, для списков определен ряд методов.
append(x) Добавляет элемент в конец последовательности
count(x) Считает количество элементов, равных x
extend(s) Добавляет к концу последовательности последовательность s
index(x) Возвращает наименьшее i, такое, что s[i] == x. Возбуждает исключение ValueError, если x не найден в s
insert(i, x) Вставляет элемент x в i-й промежуток
pop(i) Возвращает i-й элемент, удаляя его из последовательности
reverse() Меняет порядок элементов s на обратный
sort([cmpfunc]) Сортирует элементы s. Может быть указана своя функция сравнения cmpfunc
Для преобразования кортежа в список есть функция list, для обратной операции — tuple.
Об индексировании списков и выделении подпоследовательностей следует еще раз упомянуть отдельно (этот механизм работает аналогично и для строк). Для получения элемента используются квадратные скобки, в которых находится индекс элемента. Элементы нумеруются с нуля. Отрицательное значение индекса указывает на элементы с конца. Первый с конца списка (строки) элемент имеет индекс -1.
>>> s = [0, 1, 2, 3, 4]
>>> print s[0], s[-1], s[3]
0 4 3
>>> s[2] = -2
>>> print s
[0, 1, -2, 3, 4]
>>> del s[2]
>>> print s
[0, 1, 3, 4]
Сложнее обстоят дела со срезами. Для получения срезов последовательности в Python принято указывать не номера элементов, а номера «промежутков» между ними. Перед первым элементом последовательности промежуток имеет индекс 0, перед вторым – 1 и так далее. Отрицательные значения отсчитывают элементы с конца строки.
В общем виде срез записывается в следующем виде:
список[начало: конец: шаг]
По умолчанию начало среза равно 0, конец среза равен len(список), шаг равен 1. Если шаг не указывается, второй символ «:» можно опустить.
С помощью среза можно указать подмножество для вставки списка в другой список, даже при нулевой длине. Это удобно для вставки списка в строго определенной позиции.

>>> l = range(12)
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
>>> l[1:3]
[1, 2]
>>> l[-1:]
[11]
>>> l[::2]
[0, 2, 4, 6, 8, 10]
>>> l[0:1]=[-1,-1,-1]
>>> l
[-1, -1, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
>>> del l[:3]
>>> l
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Словари
Словарь (хэш, предопределенный массив) – изменяемая структура данных, предназначенная для хранения элементов вида ключ: значение. Все легко показывается на примере.
>>> h1 = {1:"one", 2:"two", 3:"three"}
>>> h2 = {0:"zero", 5:"five"}
>>> h3 = {"z":1, "y":2, "x":3}
#Цикл по паре ключ-значение
>>> for key, value in h1.items():
...     print key, " ", value
...
1   one
2   two
3   three
#Цикл по ключам
>>> for key in h2.keys():
...     print key, " ", h2[key]
0   zero
5   five
#Цикл по значениям
>>> for v in h3.values():
...     print v
2
3
1
#Добавление элементов из другого хеша
>>> h1.update(h3)
#Количество пар в хеше
>>> len(h1)
6
Тип file
Объекты этого типа предназначены для работы с внешними данными. Чаще всего данному объекту соответствует файл на диске, но это далеко не всегда так. Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
Следующий пример показывает копирование файла:
f1 = open("file1.txt", "r")
f2 = open("file2.txt", "w")
for line in f1.readlines():
  f2.write(line)
f2.close()
f1.close()
Этот пример можно записать массой других способов, многие из которых сильно отличаются по оптимальности, но это тоже тема отдельного разговора.
В принципе, большинству функций абсолютно безразлично, передан им объект типа файл, или любой другой объект с такими же методами. Так, приведенный выше пример можно очень легко модифицировать для скачивания файла из Интернета, заменив в нем первую строку на следующий код.
import urllib
f1 = urllib.urlopen("http://python.onego.ru")

Использование функций
Вот пример самой простой функции:
def empty_func():
    pass
Начинается объявление с ключевого слова def, что как не сложно догадаться является сокращением от define. После него идет имя функции. После имени в круглых скобках задается список параметров, в данном случае отсутствующих.
Тело функции пишется с отступом со следующей строки. учтите, что в Pythonе функции с пустым телом запрещены, потому в качестве тела приведенной выше функции используется «пустой оператор» pass.

Теперь рассмотрим пример посерьезнее.
def safe_div(x, y):
    """Do a safe division :-)
for fun and profit"""
    if y != 0:
        z = x / y
        print z
        return z
    else:
        print "zero division!"
В этом примере есть несколько нововведений. первое, что бросается в глаза — это строка документации (docstring), идущая сразу после тела функции.
Обычно эта строка занимает не одну строку исходного текста (простите за каламбур) и потому задается в тройных кавычках. Она предназначена для описания функции, ее предназначения, параметров и т.п. Все хорошие IDE умеют с этой строкой работать. Получить к ней доступ можно и из самой программы, используя свойство __doc__: например, print safe_div.__doc__
Этим свойством удобно пользоваться во время сеансов работы интерактивной консоли.
>>> from ftplib import FTP
>>> print FTP.__doc__
An FTP client class.

    To create a connection, call the class using these arguments:
            host, user, passwd, acct
    These are all strings, and have default value ''.
    Then use self.connect() with optional host and port argument.
....
Вернемся к нашей исходной функции. Суть ее очень проста, она принимает 2 параметра: х и у. Если у не равен 0, она делит х на у, выводит результат на экран и возвращает свое частное в виде результата. Результат функции возвращают с помощью команды return. Благодаря механизму кортежей, описанному в прошлом уроке, функции в Pythonе могут возвращать одновременно множество объектов.
Если же делитель все-таки равен нулю, функция выводит сообщение об ошибке. Неверно было бы предположить, что в этом случае функция ничего не вернет. Правильнее будет сказать, что функция вернет «ничего». Иначе говоря, если в функции отсутствует оператор return, или же он вызван без параметров, то функция возвращает специальное значение None. В этом легко убедиться вызвав что-то типа print safe_div(10, 0).

Вот пример слегка посложнее, он взят из доклада-презентации Гвидо ван Россума.
def gcd(a, b):
   "Нахождение НОД"
   while a != 0:
      a,b = b%a,a # параллельное определение
   return b
Данная функция находит наибольший общий делитель двух чисел.
В общем, следует учитывать, что параметры в функции Python передаются по ссылке. Еще одним, возможно нетривиальным фактом к которому придется привыкать — является тот факт, что сами функции являются значением, которое можно присваивать. Если воспользоваться нашей функцией safe_div для дальнейших экспериментов, то можно написать следующий код.
mystic_function = safe_div
print mystic_function(10, 4)
Параметры по-умолчанию
Для всех параметров функций можно указывать значения по-умолчанию, это дает возможность вызвать функцию с меньшим числом параметров. Например, у нас есть функция для авторизации пользователя на сайте:
def login(username="anonymous", password=None):
    """Тут какие-то действия"""
    pass
# вызвать эту функцию мы можем одним из нижеприведенных способов
login("root", "ujdyzysqgfhjkm")
login("guest")
login()
# мы можем указать какой из параметров мы передаем, 
# указав его имя в явном виде
login(password="nobody@mail.com")
Position и keyword аргументы.
Зачастую случается необходимость сделать функцию, которая обрабатывает неопределенное число параметров. Например, функция расчета суммы элементов списка.
Мы, конечно, можем передавать все аргументы как один параметр типа list, но это выглядит некрасиво. Потому в Python был придуман специальный механизм, называемый position-arguments. Вот пример, демонстрирующий использование.
In [9]: def list_sum(*args):
   ...:     smm = 0
   ...:     for arg in args:
   ...:         smm += arg
   ...:     return smm
   ...:
In [10]: list_sum(1, 2, 3)
Out[10]: 6
In [11]: list_sum(1)
Out[11]: 1
In [12]: list_sum()
Out[12]: 0
В данном случае, все наши параметры «упаковываются» в список args в соответствии с их «порядковым номером» при передаче.
Возможна и обратная операция, допустим у нас есть список значений, и мы хотим передать их как список параметров функции:
In [14]: lst = [1, 10, 2]
In [15]: list(range(*lst))
Out[15]: [1, 3, 5, 7, 9]
В этом примере список lst был «распакован» и подставлен на место параметров функции range, то есть вызов был аналогичен:
In [16]: list(range(1, 10, 2))
Out[16]: [1, 3, 5, 7, 9]
Кроме position, можно использовать и т.н. keyword аргументы. Они отличаются тем, что для них надо явно задавать имя.
Структура программы MicroPython
Несколько синтаксических правил для понимания:
Блоки кода разделяются не фигурными скобками, как в C++, а отступами(Tab-ами)
Для подключения библиотек используется конструкция import name_of_library
Если вы уже умеете программировать на Python - то никаких сложностей не возникнет, нужно только обратить своё внимание на модули предназначенные для работы с "железом"
Традиционно, первой программой для микроконтроллеров является программа Blynk - моргание встроенным в практически любую плату светодиодом.
В данном занятии используется эмулятор платы на основе ESP32, на ней встроенный светодиод связан с GPIO2.
from machine import Pin
import time
led_pin = Pin(2,Pin.OUT)
while True:
    led_pin.on()
    time.sleep(1)
    led_pin.off()
    time.sleep(1)
Для начала, необходимо импортировать библиотеки: from machine import Pin - самая популярная строка в программах на Micropython, в ней мы подключаем возможность управления пинами, библиотека time отвечает за работу со временем.
После этого необходимо связать GPIO2 с нашей переменной, и указать режим работы - Pin.OUT.
Затем в бесконечном цикле включать и выключать, то есть подавать сигнал равный 0 или 1 на наш пин, не забывая делать между этим паузу в одну секунду.
Библиотеки и модули
Основным достоинством Python, как и десктопной так и микроконтроллерной версии - большое число встроенных библиотек. Об одной из них мы уже говорили в первой статье. Что бы узнать, какие библиотеки доступны в вашей версии Micropython, достаточно набрать следующую команду: help("modules") на экран будет выведен список всех доступных библиотек.

Эта команда выводит лишь те библиотеки, которые были включены в сборку, если же вы хотите установить собственные библиотеки, то они будут загружены в флеш-память. Поговорим немного о том, как загружать дополнительные библиотеки. Есть два варианта. Первый это непосредственная загрузка файлов на ваш микроконтроллер. Необходимая библиотека скачивается на компьютер, а затем используя IDE отправляется на устройство.
Основным плюсом является наличие встроенного менеджера пакетов - upip, с помощью которого можно установить библиотеки из PyPI репозитория Python.
import upip
upip.install(“package-name”)
Для того, чтобы использовать upip, нам необходимо подключиться к интернету. Для этого существует библиотека - network.
Подключаемся к сети
Для подключения к интернету через WiFi, необходимо импортировать библиотеку, затем перевести контроллер в режим приёмника, активировать его, а затем указать данные Wi-Fi сети: SSID и пароль.
import network # Импорт библиотеки
sta_if = network.WLAN(network.STA_IF) # Режим приёмника
sta_if.active(True)
sta_if.connect('<your ESSID>', '<your password>')
Для проверки подключения существует функция - sta_if.isconnected(), а для того что бы узнать IP и mac-адреса - sta_if.ifconfig().
Пример программы
Для начала напишем простую программу, которая по очереди окрасит светодиоды в красный, зелёный и синий цвета.
import machine, neopixel
import time
np = neopixel.NeoPixel(machine.Pin(2), 8)
def color(delay = 1):
    for color in [(100,0,0),(0,100,0),(0,0,100)]:
        for index in range(8):
            np[index] = color
            np.write()
            time.sleep(delay)
Для начала необходимо импортировать библиотеки: machine - для работы с пинами, neopixel - непосредственно для работы со светодиодами и библиотеку time - она понадобится для создания задержки.
Затем необходимо инициализировать нашу светодиодную ленту. Основным достоинством адресных светодиодов является то, что для управления необходим всего один пин. В функцию необходимо передать два параметра: пин, к которому подключен управляющий канал и количество светодиодов на плате. В примере плата из 8 светодиодов подключена ко второму пину.
Для установки цвета светодиода используется кортеж из трёх чисел, каждое из которых отвечает за канал определённого цвета: R,G,B. Используя команду [index] = color мы указываем необходимый цвета, для светодиода с номером index, а команда np.write() - отображает цвета.
Теперь усложним задачу, попробуем сделать симуляцию вращения.
import machine, neopixel
import time
np = neopixel.NeoPixel(machine.Pin(2), 8)
def tic(first_index = 0):
    color = [(100,0,0),(0,100,0),(0,0,100),(100,100,100)]
    i = 0
    for index in range(first_index,8+first_index,2):
        np[index%8] = color[i]
        np[(1+index)%8] = color[i]
        i+=1
    np.write()
i = 0
while True:
    tic(i)
    i = (i+1)%8 
    time.sleep(0.2)
Функция tic(first_index = 0) раскрашивает каждую пару светодиодов начиная с заданного в разные цвета. Передвигая цвета по одному - то есть сдвигая на один элемент - можно добиться "симуляции" вращения.
Симулятор ESP32
Симулятор ПЛК ESP32 WokWi рекомендуется по трем причинам:
Возможность программирования на MicroPython;
Возможность использования FreeRTOS — многозадачной операционной системы реального времени (ОСРВ) для встраиваемых систем;
Возможность симуляции работы с WiFi и доступом к внешним ресурсам.
Первый пример будет похож на программу для работы с светодиодной подсветкой, написанную выше. Для начала работы зайдите на сайт https://www.hackster.io/Hack-star-Arduino/esp32-online-systems-simulator-you-were-looking-for-2022-327d42#toc-micropython-examples-3 в секцию MicroPython:

Можно перейти на NeoPixels и увидеть следующее окно:

В левой части экрана будет видна программа на MicroPython, в правой части – окно с симуляцией работы ESP с подключенной светодиодной подсветкой. Нажмите зеленую кнопку симуляции  в средней части экрана и убедитесь, что включилась анимация. Программу можно редактировать после остановки симуляции и запускать вновь.
Другой пример программы – эмулятор OLED-экрана (SSD1306 Example)

В консоли внизу можно итерактивно выполнять команды, например, показан вывод команды help("modules").


Третий пример – работа с WiFi


Как видно, основная часть программы отработала и вывела список доступных WiFi сетей (на текущий момент – SSID «Wokwi-GUEST», к которой симулятор может подключиться без пароля). Попробуем подключиться к сети, выполнив ряд команд в консоли (черное поле под изображением ПЛК ESP32):
>>> sta_if = network.WLAN(network.STA_IF) 
>>> sta_if.active(True)
True
>>> sta_if.connect('Wokwi-GUEST')
>>> sta_if.isconnected()
True
>>> sta_if.ifconfig()
('10.10.0.2', '255.255.0.0', '10.0.0.1', '10.0.0.1')
Из результатов выполнения можно сделать вывод о подключении к сети. 
Введенные команды подключения к сети можно перенести в тело программы main.py

Эмуляция сетевых подключений (WiFi)
Получение сведений о погоде с сайта openweathermap.org
Перед началом работы необходимо зарегистрироваться на сайте и получить API ключ, учитывающий и регулирующий количество бесплатных и коммерческих запросов от пользователей. 

Можно воспользоваться ключом преподавателя 0cc74ed35fd4986c1741ee29ed94721e, если он еще актуален.
После получения ключа сформируем и отправим запрос, разберем ответный пакет в формате JSON, и получим текущую температуру с описанием состояния погоды.
Формирование строки запроса для поиска интересующего нас города в базе:
http://api.openweathermap.org/data/2.5/find?q=Perm&type=like&APPID=0cc74ed35fd4986c1741ee29ed94721e
В запросе нужно указать нужный город (вместо «Perm») и свой App Id (вместо 0cc74ed35fd4986c1741ee29ed94721e. Можно уточнить запрос, указав идентификатор страны после названия города через запятую. Например, введите в браузере:
https://api.openweathermap.org/data/2.5/find?q=Perm,RU&type=like&APPID=0cc74ed35fd4986c1741ee29ed94721e&units=metric
и получите ответ:
{"message":"like","cod":"200","count":1,"list":[{"id":511196,"name":"Perm","coord":{"lat":58.0174,"lon":56.2855},"main":{"temp":-0.3,"feels_like":-2.81,"temp_min":-0.31,"temp_max":-0.3,"pressure":1017,"humidity":93},"dt":1649473749,"wind":{"speed":2,"deg":110},"sys":{"country":"RU"},"rain":null,"snow":null,"clouds":{"all":20},"weather":[{"id":701,"main":"Mist","description":"mist","icon":"50d"}]}]}
Разобрав этот ответ, можно найти требуемую информацию о погоде. 
Для дальнейшей работы нам понадобится код города "id":511196, поскольку запрос может возвратить несколько городов, например, населенный пункт Moscow есть не только в России, но и в США. Поэтому в запросы будем подставлять идентификатор города. При этом можно уже не использовать точку входа "find", а обращаться к "weather". Дополнительно можно отправлять в запросе требуемый язык для предоставления данных - русский (lang=RU). В итоге получаем запрос такого типа, который, в дальнейшем, необходимо встроить в программу.
https://api.openweathermap.org/data/2.5/weather?id=511196&APPID=0cc74ed35fd4986c1741ee29ed94721e&units=metric&lang=RU
ответ в формате JSON:
{"coord":{"lon":56.2855,"lat":58.0174},"weather":[{"id":802,"main":"Clouds","description":"переменная облачность","icon":"03d"}],"base":"stations","main":{"temp":1.7,"feels_like":-1.46,"temp_min":1.7,"temp_max":1.7,"pressure": 1017,"humidity":87},"visibility":10000,"wind":{"speed":3,"deg":110},"clouds":{"all":40},"dt":1649477393,"sys":{"type":1,"id":8984,"country":"RU","sunrise":1649467268,"sunset":1649517088},"timezone":18000,"id":511196,"name":"Пермь","cod":200}
Теперь перейдем к составлению программы для выполнения запросов и обработки результатов. Итоговая строка запроса будет сформирована самой библиотекой requests в функции get и будет выглядеть примерно так:
В urequests нет params, поэтому надо как-то иначе формировать запрос. Я пробовал сформировать такой же запрос как выше, соединив несколько строк, но не получилось.
requests.get("http://api.openweathermap.org/data/2.5/find", params={'id':city_id,'units':'metric','lang':'ru','APPID':appid}) 
import urequests # в MicroPython – urequests вместо requests!!!
city_id = 511196          # код города
appid = "0cc74ed35fd4986c1741ee29ed94721e"  # код APPID
try:
    res = urequests.get("http://api.openweathermap.org/data/2.5/weather",
      params={'id': city_id, 'units': 'metric', 'lang': 'ru', 'APPID': appid})
    data = res.json()
    print("conditions:", data['weather'][0]['description'])
    print("temp:", data['main']['temp'])
    print("temp_min:", data['main']['temp_min'])
    print("temp_max:", data['main']['temp_max'])
except Exception as e:
    print("Exception (weather):", e)
    pass
Можно реализовать собственный веб сервер, работающий на ESP32, как описано в примере https://wokwi.com/projects/320964045035274834 . Этот сервер позволяет управлять двумя светодиодами с простейшей странички с двумя кнопками.
Работа с MQTT с использованием сетевых подключений 
В данном разделе рассмотрим структуру распределенной информационной системы, состоящей из устройства IoT с датчиком температуры и веб-ресурса для сбора информации с устройства. 
MQTT – система обмена сообщениями с использованием брокера 
Для взаимодействия между собой устройства используют различные промышленные протоколы, одним из популярных протоколов для этой цели является MQTT.
MQTT или Message Queue Telemetry Transport – это легкий, компактный и открытый протокол обмена данными, созданный для передачи данных на удалённых локациях, где требуется небольшой размер кода и есть ограничения по пропускной способности канала. Вышеперечисленные достоинства позволяют применять его в системах M2M (Машинно-Машинное взаимодействие) и IIoT (Промышленный Интернет вещей).
Также существует версия протокола MQTT-SN (MQTT for Sensor Networks), ранее известная как MQTT-S, которая предназначена для встраиваемых беспроводных устройств без поддержки TCP/IP сетей, например, Zigbee.
Основные особенности протокола MQTT:
Асинхронный протокол
Компактные сообщения
Работа в условиях нестабильной связи на линии передачи данных
Поддержка нескольких уровней качества обслуживания (QoS)
Легкая интеграция новых устройств
Протокол MQTT работает на прикладном уровне поверх TCP/IP и использует по умолчанию 1883 порт (8883 при подключении через SSL).

Обмен сообщениями в протоколе MQTT осуществляется между клиентом (client), который может быть издателем или подписчиком (publisher/subscriber) сообщений, и брокером (broker) сообщений (например, Mosquitto MQTT).
Издатель отправляет данные на MQTT брокер, указывая в сообщении определенную тему, топик (topic). Подписчики могут получать разные данные от множества издателей в зависимости от подписки на соответствующие топики.
Устройства MQTT используют определенные типы сообщений для взаимодействия с брокером, ниже представлены основные:
Connect – установить соединение с брокером
Disconnect – разорвать соединение с брокером
Publish – опубликовать данные в топик на брокере
Subscribe – подписаться на топик на брокере
Unsubscribe – отписаться от топика
Схема простого взаимодействия между подписчиком, издателем и брокером

Семантика топиков
Топики представляют собой символы с кодировкой UTF-8. Иерархическая структура топиков имеет формат «дерева», что упрощает их организацию и доступ к данным. Топики состоят из одного или нескольких уровней, которые разделены между собой символом «/».
Пример топика в который датчик температуры, расположенный в спальной комнате публикует данные брокеру:
/home/living-space/living-room1/temperature
Подписчик может так же получать данные сразу с нескольких топиков, для этого существуют wildcard. Они бывают двух типов: одноуровневые и многоуровневые.
Структура сообщений
MQTT сообщение состоит из нескольких частей:
Фиксированный заголовок (присутствует по всех сообщениях)
Переменный заголовок (присутствует только в определенных сообщениях)
Данные, «нагрузка» (присутствует только в определенных сообщениях)
Более подробную информацию о безопасности, настройках QoS и типах сообщений можно найти по ссылке. 
Пример программы для работы с MQTT можно найти по адресу https://wokwi.com/projects/322577683855704658 . Этот пример рекомендуется взять за основу для выполнения практического задания.
В правой части симулятора размещен код примера:

В самом начале написана рекомендация по просмотру данных: используется открытый брокер MQTT. К которому можно бесплатно подключать устройства и через браузер просматривать полученные сообщения. Для обмена сообщениями используется топик «wokwi-weather». Для выполнения практической работы измените этот топик на свой, включающий фамилию, записанную латинскими буквами.
В правой части находится ПЛК и внизу его командная строка

После запуска симуляции, происходит подключение к WiFi сети, подключение к брокеру MQTT, инициализация датчика. 
Далее, в бесконечном цикле происходит опрос датчика, определение температуры и влажности, и (если произошло изменение) отправка сообщения брокеру. Значение температуры и влажности можно изменять, как показано на рисунке выше.
Для просмотра сообщений зайдите на http://www.hivemq.com/demos/websocket-client/ 

Нажмите «Connect» для подключения и создайте новый топик – Add New Topic Subscription (в исходном примере «wokwi-weather») и нажмите Subscribe

После этого необходимо запустить симуляцию и изменить несколько раз значения температуры и влажности. В результате будут отправлены новые сообщения и отобразятся на странице

При выполнении задания необходимо модифицировать схему симуляции, например, добавив экран для отображения текущей температуры. Для этого на закладке diagram.json добавьте строку компонентов (parts), выделенную цветом
 
Появится изображение экрана, теперь надо выполнить подключение к ПЛК. Для этого измените раздел connections
Тут не esp:D22, esp:D21, а esp:22, esp:21 (esp:D15 в примере тоже написан как esp:15)


Теперь необходимо модифицировать код. Добавьте выделенный текст.

Запустить этот код не получится, т.к. система не сможет найти код модуля ssd1306.
Для того, чтобы добавить этот модуль нажмите New file в Library Manager:

Назовите новый файл ssd1306.py и скопируйте в него код из файла ssd1306.py из проекта «SSD1306 Example» https://wokwi.com/projects/305568836183130690.   
Возможно, этот шаг можно выполнить более цивилизованным методом через поиск и добавление библиотек в Library Manager, но у меня не получилось

После этого можно запустить симуляцию проекта и убедиться, что экран работает.
После этого необходимо добавить вывод информации о температуре/влажности на экран, используя функцию вывода текста на OLED в нужные координаты в формате 'T='+str(sensor.temperature())
Этот вывод надо осуществлять в цикле после измерения sensor.measure()
Очистку экрана можно выполнять функцией clearDisplay()

Задание на выполнение практической работы:
Это описание является основой лабораторного стенда, симулирующего некоторую распределенную промышленную систему.  Требуется дополнить эту систему пользовательским интерфейсом, средствами сохранения данных в БД, и провести исследование с точки зрения ИБ.
Ознакомиться с теоретическими сведениями из пособия
Запустить симулятор(ы) ESP32 из примеров для получения навыков работы
Запустить симулятор работы с MQTT (https://wokwi.com/projects/322577683855704658) и настроить получение сообщений на браузерном клиенте на http://www.hivemq.com/demos/websocket-client/   
Выполнить первую модификацию, связанную с изменением топика в соответствии со своей фамилией
Выполнить вторую модификацию, связанную с добавлением нового узла – OLED экрана и изменить программу для вывода информации на экран.
Создать приложение (локально), считывающее по протоколу MQTT информацию с Hivemq для своей подписки и сохраняющее их в виде отсчетов в БД.
Создать простой Web-сервер (локально), который считывает информацию об отсчетах за нужную дату из БД, и отображает их в HTML-виде. Проверить работу сервера через браузер. Добавить средства аутентификации на   Web-сервер.
Исследовать вопросы инфобезопасности полученной распределенной системы. Например, с использованием открытых фреймворков. Исследовать методы безопасного хранения «секретов» (пароли к БД, строи подключения, API-ключи)
Оформить отчет о выполнении работы с приведением снимков экрана с пояснениями, описанием результата и заключением Приложение 1
Библиотеки для работы с ESP32. Информация взята из открытых источников
Общее управление платой
Модуль machine:
import machine

machine.freq()          # прочесть текущую частоту CPU
machine.freq(240000000) # задать частоту CPU на 240 МГц
Модуль esp:
esp.osdebug(None)       # выключить отладочные сообщения ОС
esp.osdebug(0)          # перенаправить отладочные сообщения ОС
                        # на порт UART0

# низкоуровневые методы для взаимодействия с flash-памятью:
esp.flash_size()
esp.flash_user_start()
esp.flash_erase(sector_no)
esp.flash_write(byte_offset, buffer)
esp.flash_read(byte_offset, buffer)
Модуль esp32:
import esp32

esp32.hall_sensor()     # прочесть данные встроенного датчика Холла
esp32.raw_temperature() # прочесть внутреннюю температуру MCU
                        # (в Фаренгейтах)
esp32.ULP()             # получить доступ к ULP-сопроцессору
                        # (от англ. «ultra-low power», что значит
                        # «ультранизкое энергопотребление»)

Сеть
Модуль networking:
import network

wlan = network.WLAN(network.STA_IF) # создать интерфейс станции
wlan.active(True)       # активировать интерфейс
wlan.scan()             # сканировать точки доступа
wlan.isconnected()      # проверить, подключена ли станция
                        # к точке доступа
wlan.connect('essid', 'пароль') # подключиться к точке доступа 
wlan.config('mac-адрес')      # прочесть MAC-адрес устройства
wlan.ifconfig()         # прочесть IP-адрес, маску подсети,
                        # сетевой шлюз и DNS-сервер

ap = network.WLAN(network.AP_IF) # создать интерфейс точки доступа 
ap.config(essid='ESP-AP') # задать ESSID точки доступа
ap.config(max_clients=10) # задать количество клиентов,
                          # которые могут подключиться к сети
ap.active(True)         # активировать интерфейс
Полезная функция для подключения к локальной WiFi-сети:
def do_connect():
    import network
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    if not wlan.isconnected():
        print('подключение к сети...')
        wlan.connect('essid', 'пароль')
        while not wlan.isconnected():
            pass
    print('настройки сети:', wlan.ifconfig())
Когда связь будет установлена, можно воспользоваться модулем socket, чтобы как обычно создать и использовать сокеты TCP/UDP, а затем модулем urequests – для создания удобных HTTP-запросов.


Задержки и синхронизация
модуль time:
import time

time.sleep(1)           # включить режим сна на 1 секунду
time.sleep_ms(500)      # включить режим сна на 500 миллисекунд
time.sleep_us(10)       # включить режим сна на 10 микросекунд
start = time.ticks_ms() # прочесть показатель счетчика микросекунд
delta = time.ticks_diff(time.ticks_ms(), start) # вычислить разницу
                                                # во времени


Таймеры
В порте MicroPython для ESP32 поддерживаются виртуальные (RTOS) таймеры. Используйте класс machine.Timer с ID таймера «-1».
from machine import Timer

tim = Timer(-1)
tim.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))
tim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2))
Значение в period указывается в миллисекундах.

Контакты и GPIO
Используйте класс machine.Pin.
from machine import Pin

p0 = Pin(0, Pin.OUT)    # создать выходной контакт на GPIO0
p0.on()                 # задать контакту значение «вкл» 
p0.off()                # задать контакту значение «выкл»
p0.value(1)             # задать контакту значение «вкл» («1»)

p2 = Pin(2, Pin.IN)     # создать входной контакт на GPIO2
print(p2.value())       # прочесть значение («0» или «1»)

p4 = Pin(4, Pin.IN, Pin.PULL_UP) # включить встроенный
                                 # подтягивающий резистор
p5 = Pin(5, Pin.OUT, value=1) # создать выходной контакт
                              # со значением «вкл» («1»)
На ESP32 доступны следующие контакты (включительно): 0-19, 21-23, 25-27, 32-39. Эти номера соответствуют физическим номерам GPIO-контактов чипа ESP32. Имейте в виду, что у многих плат используется собственная нумерация контактов (например, D0, D1 и т.д.). О том, как эта логическая нумерация соответствует нумерации контактов самого ESP32-чипа, читайте в документации к своей плате. Примечания:
Контакты 1 и 3 – это, соответственно, TX- и RX-контакты UART-порта для REPL
Контакты 6, 7, 8, 11, 16 и 17 используются для подключения к встроенной flash-памяти, поэтому для других целей их использовать не рекомендуется
Контакты 34-39 можно использовать только в качестве входных контактов (поэтому у них нет встроенных подтягивающих резисторов)
В параметре для включения/выключения подтягивающего резистора также можно указать (помимо PULL_UP и PULL_DOWN) значение PULL_HOLD, что позволит снизить энергопотребление во время работы в режиме глубокого сна

ШИМ (широтно-импульсная модуляция)
ШИМ можно включить на всех контактах, которые можно использовать как выходные контакты. Базовая частота может варьироваться между 1 Гц и 40 МГц, но есть одно ограничение – при увеличении базовой частоты уменьшается разрешение коэффициента заполнения. Более подробно об этом читайте в этой статье. В данный момент диапазон значений коэффициента заполнения составляет 0-1023.
Используйте класс machine.PWM.
from machine import Pin, PWM

pwm0 = PWM(Pin(0))      # создать ШИМ-объект на контакте
pwm0.freq()             # прочесть текущую частоту
pwm0.freq(1000)         # задать частоту
pwm0.duty()             # прочесть текущий коэффициент заполнения
pwm0.duty(200)          # задать коэффициент заполнения
pwm0.deinit()           # выключить ШИМ на контакте

pwm2 = PWM(Pin(2), freq=20000, duty=512) # создать и настроить ШИМ
                                         # за один раз
АЦП (аналогово-цифровое преобразование)
На ESP32 аналогово-цифровое преобразование доступно на каналах 32-39. Помните, что при использовании настроек по умолчанию входное напряжение на АЦП-контакте должно быть в диапазоне между 0.0 и 1.0 вольтами (любое напряжение больше 1.0 вольта будет считываться как «4095»). Чтобы увеличить диапазон считываемого напряжения, нужно применить аттенюацию.
Используйте класс machine.ADC:
from machine import ADC

adc = ADC(Pin(32))          # создать АЦП-объект на АЦП-контакте 
adc.read()                  # прочесть значение в диапазоне 0-4095
                            # по напряжению между 0.0 и 1.0 вольтами

adc.atten(ADC.ATTN_11DB)    # включить входную аттенюацию на 11 дБ
                            # (диапазон сменится на 0.0-3.6 вольт) 
adc.width(ADC.WIDTH_9BIT)   # задать 9-битное разрешение
                            # возвращаемых значений (0-511) 
adc.read()                  # прочесть значение, используя
                            # новые аттенюацию и разрешение
Вот методы класса machine.ADC, отвечающие за аттенюацию и разрешение:
ADC.atten(attenuation). Этот метод позволяет включить аттенюацию на входе в АЦП-контакт, а следовательно – задать более широкий диапазон входящего напряжения, но ценой точности (потому что за этот более широкий диапазон отвечает прежнее количество битов). Вот возможные варианты для параметра attenuation:
ADC.ATTN_0DB – аттенюация 0 дБ, делает максимальным порогом входящего напряжения 1.00 вольт (это настройка по умолчанию)
ADC.ATTN_2_5DB: аттенюация 2.5 дБ, делает максимальным порогом входящего напряжения примерно 1.34 вольт
ADC.ATTN_6DB: аттенюация 6 дБ, делает максимальным порогом входящего напряжения примерно 2.00 вольта
ADC.ATTN_11DB: аттенюация 11 дБ, делает максимальным порогом входящего напряжения примерно 3.6 вольт
Внимание: Хотя аттенюация в 11 дБ позволяет поднять диапазон считываемого напряжения до 3.6 вольт, помните, что максимально допустимое напряжение для входных контактов – это 3.6 вольт, и приближение к этому порогу может повредить схему.
ADC.width(width). Этот метод позволяет задать количество бит для данных, возвращаемых при считывании АЦП-информации. Возможные варианты:
ADC.WIDTH_9BIT: 9-битные данные
ADC.WIDTH_10BIT: 10-битные данные
ADC.WIDTH_11BIT: 11-битные данные
ADC.WIDTH_12BIT: 12-битные данные (это настройка по умолчанию)
Кроме перечисленных библиотек и модулей доступны модули для работы с SPI, I2C, работа с режимами энергоэффективности (сон, пробуждение по сигналу) и многое другое.
